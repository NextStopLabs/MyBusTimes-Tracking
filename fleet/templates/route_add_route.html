{% extends 'mbtbase.html' %}
{% load static %}

{% block title %}{{ full_route_num }}{% endblock %}

{% block extra_css %}
<link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
<style>
  html, body { height: 100%; overflow: hidden; }
  main { height: calc(100vh - 55px); }
  #map { position: fixed !important; top: 55px; bottom: 0; right: 0; width: 65%; }
  .stop-list { position: fixed; top: 55px; left: 0; bottom: 0; width: 35%; background: var(--background-color); display: flex; flex-direction: column; z-index: 10; }
  .stop-list-content { flex: 1 1 auto; overflow-y: auto; }
  .stop-list-footer { flex: 0 0 auto; padding: 10px; display: flex; gap: .5rem; box-shadow: 0 -2px 4px rgb(0 0 0 / .1); background: var(--background-color); }
  th:first-child, td:first-child { text-wrap: auto; }
  th:last-child, td:last-child { width: 25px; }
  .remove-link { margin: 0 7.5px; color: rgb(196, 30, 30); cursor: pointer; width: 25px; text-align: center; }
  .timing-point { transform: rotate(-90deg); border: 0; font-weight: normal; text-align: center; padding: 5px; margin-top: 40px; display: block; }
  .timing-point-check-box { width: 0; text-align: center; }
  @media (max-width: 768px) {
    #map { width: 100%; height: 60vh; }
    .stop-list { top: 60vh; width: 100%; }
  }
  .maplibregl-popup-tip,
  .maplibregl-popup-content {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border-radius: 0.5em !important;
    font-size: 12px !important;
  }
</style>
{% endblock %}

{% block extra_js %}
<script src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"></script>
{% endblock %}

{% block content %}
<div id="map"></div>

<div class="stop-list">
  <div class="stop-list-content">
    <table border="0" cellpadding="5" cellspacing="0" style="width: 100%;">
      <thead>
        <tr>
          <th>
            <h2>Add Stops, {{ route.route_num }} to {% if direction == 'inbound' %}{{ route.inbound_destination }}{% else %}{{ route.outbound_destination }}{% endif %}</h2>
            <h3 style="margin: 0;">Stop Name</h3>
            <button onclick="location.href='{% url 'edit-stop-names-only' operator_slug=operator.operator_slug route_id=route.id direction=direction %}'">
              Edit Stop Names Only
            </button>
          </th>
          {% if user.sub_plan == "pro" %}
          <th>Distance</th>
          <th>Time</th>
          {% endif %}
          <th class="timing-point">Timing Point</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="stopList"></tbody>
    </table>
  </div>

  <div class="stop-list-footer">
    <button id="addCustomStop">Add Custom Stop</button>
    <button id="submitRoute">Save {{ direction }} stops</button>
  </div>
</div>

<form id="routeForm" action="" method="POST">
  {% csrf_token %}
  <input type="hidden" name="snappedGeometry" id="snappedGeometryInput">
  <input type="hidden" name="routeData" id="routeDataInput">
</form>

<script>
  const savedView = JSON.parse(localStorage.getItem('mbt_map_view') || 'null');
  let hasPro = {% if user.sub_plan == "pro" %}true{% else %}false{% endif %};
  let tilesJSON = 'https://tiles.snubs.dev/styles/light/style.json';
  {% if themeDark == 'True' %}
    tilesJSON = 'https://tiles.snubs.dev/styles/dark/style.json';
  {% endif %}

  const map = new maplibregl.Map({
    container: 'map',
    style: tilesJSON,
    center: savedView?.center || [-2.5, 54.5],
    zoom: savedView?.zoom || 5,
    dragRotate: false
  });

  map.addControl(new maplibregl.NavigationControl(), 'top-left');

  const stopList = document.getElementById('stopList');
  const selectedStops = [];
  const selectedCoords = [];
  const markers = [];
  let snappedSegments = []; // will hold objects { coords: [[lng,lat],...], distance: meters, time: seconds }
  window.snappedFullGeometry = null;

  // Haversine fallback for distance (metres)
  function haversineDistance(a, b) {
    const toRad = v => v * Math.PI / 180;
    const R = 6371000;
    const dLat = toRad(b[1] - a[1]);
    const dLon = toRad(b[0] - a[0]);
    const lat1 = toRad(a[1]);
    const lat2 = toRad(b[1]);
    const sinDLat = Math.sin(dLat/2);
    const sinDLon = Math.sin(dLon/2);
    const hav = sinDLat*sinDLat + Math.cos(lat1)*Math.cos(lat2)*sinDLon*sinDLon;
    return 2 * R * Math.asin(Math.sqrt(hav));
  }

  // Polyline6 decoder (Valhalla)
  // Polyline6 decoder (Valhalla)
function decodeValhalla(encoded) {
    let index = 0;
    let lat = 0;
    let lon = 0;
    const coordinates = [];

    while (index < encoded.length) {

        // Decode latitude
        let result = 1;
        let shift = 0;
        let b;
        do {
            b = encoded.charCodeAt(index++) - 63 - 1;
            result += b << shift;
            shift += 5;
        } while (b >= 0x1f);
        lat += (result & 1) ? ~(result >> 1) : (result >> 1);

        // Decode longitude
        result = 1;
        shift = 0;
        do {
            b = encoded.charCodeAt(index++) - 63 - 1;
            result += b << shift;
            shift += 5;
        } while (b >= 0x1f);
        lon += (result & 1) ? ~(result >> 1) : (result >> 1);

        coordinates.push([lon / 1e6, lat / 1e6]);
    }

    return coordinates;
  }

  async function snapSegment(from, to) {
    // returns { coords:[[lon,lat],...], distance:meters, time:seconds } or null
    if (!hasPro) return null;
    

    const url = "/api/valhalla/route/";

    const body = {
        locations: [
            { lat: from.lat, lon: from.lon },
            { lat: to.lat,   lon: to.lon   }
        ],
        costing: "bus",
        directions_options: { units: "meters" }
    };

    try {
        const res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
        });

        if (!res.ok) {
            console.error("Valhalla error:", res.status);
            return null;
        }

        const data = await res.json();

        const leg = data?.trip?.legs?.[0];
        if (!leg) return null;

        // Decode polyline into [lon,lat]
        const shape = leg.shape;
        const coords = decodeValhalla(shape);

        const distance = Math.round(leg.summary.length * 1000);
        const time = Math.round(leg.summary.time);

        return { coords, distance, time };
    } catch (err) {
        console.error("Snap failed:", err);
        return null;
    }
  }

  async function autoSnapRoute() {
    const n = selectedCoords.length;
    if (n < 2) {
        snappedSegments = [];
        drawRoute();
        updateStopDistances();
        return;
    }

    if (snappedSegments.length > n - 1) {
        snappedSegments.length = n - 1;
    }

    let dirty = false;
    for (let i = 0; i < n - 1; i++) {
        const from = selectedCoords[i];
        const to = selectedCoords[i + 1];
        const existing = snappedSegments[i];

        if (!existing || existing.fromCoord !== from || existing.toCoord !== to) {
            snappedSegments[i] = {
                coords: [[from.lon, from.lat], [to.lon, to.lat]],
                distance: Math.round(haversineDistance([from.lon, from.lat],[to.lon, to.lat])),
                time: Math.round(haversineDistance([from.lon, from.lat],[to.lon, to.lat]) / 8.333333),
                fromCoord: from,
                toCoord: to,
                isPlaceholder: true
            };
            dirty = true;
        }
    }

    if (dirty) {
        drawRoute();
        updateStopDistances();
    }

    for (let i = 0; i < n - 1; i++) {
        if (snappedSegments[i].isPlaceholder) {
            const from = selectedCoords[i];
            const to = selectedCoords[i + 1];
            const snapped = await snapSegment(from, to);
            if (snapped) {
                snappedSegments[i] = { ...snapped, fromCoord: from, toCoord: to, isPlaceholder: false };
                drawRoute();
                updateStopDistances();
            } else {
                snappedSegments[i].isPlaceholder = false;
            }
        }
    }
  }

  function addStopMarker(lat, lng, name, timing_point = false) {
    const el = document.createElement('div');
    el.style.cssText = 'width:10px;height:10px;border:3px solid #2f80ea;border-radius:50%;background:#fff;cursor:pointer;';
    const marker = new maplibregl.Marker({ element: el })
      .setLngLat([lng, lat])
      .setPopup(new maplibregl.Popup({ offset: 6 }).setHTML(name))
      .addTo(map);

    el.addEventListener('click', () => {
      selectedStops.push(name);
      selectedCoords.push({ lat, lon: lng, heading: null });
      addStopToList(name, timing_point);
      autoSnapRoute();
    });

    markers.push(marker);
  }

  function clearMarkers() {
    for (const m of markers) m.remove();
    markers.length = 0;
  }

  function addStopToList(name, timing_point = false) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${name}</td>`
    if (hasPro) {
      tr.innerHTML += `<td class="stop-distance"></td>
                      <td class="stop-time"></td>`;
    }
    tr.innerHTML += `
                    <td class="timing-point-check-box">
                      <input type="checkbox" id="timing_point" ${timing_point ? 'checked' : ''}>
                    </td>
                    <td><span class="remove-link">X</span></td>`;
    const removeLink = tr.querySelector('.remove-link');

    removeLink.addEventListener('click', () => {
      const index = selectedStops.indexOf(name);
      if (index !== -1) {
        selectedStops.splice(index, 1);
        selectedCoords.splice(index, 1);
        snappedSegments.splice(index, 1);
        tr.remove();
        autoSnapRoute();
      }
    });

    stopList.appendChild(tr);
  }

  function drawRoute() {
    if (!map.isStyleLoaded()) return;

    let combined = [];
    for (let i = 0; i < snappedSegments.length; i++) {
        let seg = snappedSegments[i].coords;
        if (!seg) continue;
        if (combined.length && seg.length) seg = seg.slice(1);
        combined.push(...seg);
    }

    window.snappedFullGeometry = combined;

    if (!map.getSource("routeLine")) {
        map.addSource("routeLine", {
            type: "geojson",
            data: { type: "Feature", geometry: { type: "LineString", coordinates: combined } }
        });
        map.addLayer({
            id: "routeLine",
            type: "line",
            source: "routeLine",
            paint: { "line-color": "#2f80ed", "line-width": 3 }
        });
    } else {
        map.getSource("routeLine").setData({
            type: "Feature",
            geometry: { type: "LineString", coordinates: combined }
        });
    }
  }

  function updateStopDistances() {
    const rows = Array.from(document.querySelectorAll('#stopList tr'));
    if (!rows.length) return;

    // Build segment distances/times
    const segmentInfo = [];
    for (let i = 0; i < selectedCoords.length - 1; i++) {
        const seg = snappedSegments[i];
        if (seg && seg.distance != null && seg.time != null) {
            segmentInfo[i] = { distance: seg.distance, time: seg.time };
        } else {
            const a = [selectedCoords[i].lon, selectedCoords[i].lat];
            const b = [selectedCoords[i + 1].lon, selectedCoords[i + 1].lat];
            const dist = Math.round(haversineDistance(a, b));
            const assumedSpeed = 8.333333; // 30 km/h
            segmentInfo[i] = {
                distance: dist,
                time: Math.round(dist / assumedSpeed)
            };
        }
    }

    // Fill rows
    let cumulativeDistance = 0;
    let cumulativeTime = 0;

    for (let i = 0; i < rows.length; i++) {
        const distCell = rows[i].querySelector('.stop-distance');
        const timeCell = rows[i].querySelector('.stop-time');

        if (!hasPro) continue;

        if (i === 0) {
            distCell.textContent = '0 m';
            timeCell.textContent = '0 s';
        } else {
            const seg = segmentInfo[i - 1];
            cumulativeDistance += seg.distance;
            cumulativeTime += seg.time;
            distCell.textContent = `${cumulativeDistance} m`;
            timeCell.textContent = `${cumulativeTime} s`;
        }
    }
  }

  async function fetchStops() {
    const zoom = map.getZoom();
    if (zoom < 15) return;

    const b = map.getBounds();
    const query = new URLSearchParams({
      ymax: b.getNorth(),
      ymin: b.getSouth(),
      xmax: b.getEast(),
      xmin: b.getWest()
    }).toString();

    try {
      const res = await fetch(`https://stops.mybustimes.cc/api/stops?${query}`);
      const data = await res.json();
      clearMarkers();
      for (const s of data) {
        const lat = s.lat, lng = s.lon;
        const name = s.name || s.properties?.name || `Stop ${lat.toFixed(4)},${lng.toFixed(4)}`;
        addStopMarker(lat, lng, name);
      }
    } catch (e) {
      console.error('Stop fetch failed', e);
    }
  }

  map.on('moveend', fetchStops);
  map.on("load", () => {
    fetchStops();
    autoSnapRoute();
  });

  document.getElementById('addCustomStop').addEventListener('click', () => {
    alert('Click anywhere on the map to add a custom stop.');
    const clickHandler = (e) => {
      const lngLat = e.lngLat;
      const name = prompt('Enter stop name:');
      if (name) {
        addStopMarker(lngLat.lat, lngLat.lng, name);
        selectedStops.push(name);
        selectedCoords.push({ lat: lngLat.lat, lon: lngLat.lng, heading: null });
        addStopToList(name);
        autoSnapRoute();
      }
      map.off('click', clickHandler);
    };
    map.on('click', clickHandler);
  });

  document.getElementById("submitRoute").addEventListener("click", () => {
    const formatted = [];
    const rows = Array.from(document.querySelectorAll('#stopList tr'));

    updateStopDistances();

    let cumulativeDistance = 0;
    let cumulativeTime = 0;
    for (let i = 0; i < rows.length; i++) {
        const stop = selectedStops[i];
        const coord = selectedCoords[i];
        const timing_point = rows[i].querySelector('input[type="checkbox"]').checked;

        if (i === 0) {
          cumulativeDistance = 0;
          cumulativeTime = 0;
        } else {
          const seg = snappedSegments[i-1];
          if (seg && seg.distance != null && seg.time != null) {
            cumulativeDistance += seg.distance;
            cumulativeTime += seg.time;
          } else {
            const a = [selectedCoords[i-1].lon, selectedCoords[i-1].lat];
            const b = [coord.lon, coord.lat];
            const dist = Math.round(haversineDistance(a,b));
            cumulativeDistance += dist;
            cumulativeTime += Math.round(dist / 8.333333);
          }
        }

        formatted.push({
          stop,
          cords: `${coord.lat},${coord.lon}`,
          timing_point,
          distance_m: cumulativeDistance,
          time_s: cumulativeTime
        });
    }

    // Create payload matching the structure your view expects
    const payload = {
        stops: formatted,
        snapped_geometry: window.snappedFullGeometry || []
    };

    document.getElementById("routeDataInput").value = JSON.stringify(payload);

    // Remove the separate snappedGeometry input since it's now in the payload
    if (window.snappedFullGeometry) {
        document.getElementById("snappedGeometryInput").value = JSON.stringify(window.snappedFullGeometry);
    } else {
        document.getElementById("snappedGeometryInput").value = "";
    }

    document.getElementById("routeForm").submit();
});
</script>

{% endblock %}