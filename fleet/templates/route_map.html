{% extends 'mbtbase.html' %}
{% load static %}
{% load url_filters %}

{% block title %}{{ route.route_num }} Route Map{% endblock %}

{% block extra_css %}
<link href="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.css" rel="stylesheet" />


<style>
  html, body, main {
    height: 100%;
    margin: 0;
    padding: 0;
  }

  #map {
    position: fixed !important;
    top: 55px;
    bottom: 0;
    width: 100%;
    left: 0;
  }

  #directionToggle {
    position: fixed;
    bottom: 10px;
    left: 10px;
    z-index: 1000;
    background: var(--brand-color);
    color: var(--text-color);
    padding: 6px 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  #stopsToggle {
    position: fixed;
    bottom: 50px;
    left: 10px;
    z-index: 1000;
    background: var(--brand-color);
    color: var(--text-color);
    padding: 6px 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  .vehicle-marker {
    text-align: center;
    color: #000;
    fill: currentColor;
    text-anchor: middle;
    paint-order: stroke;
    stroke-width: 2px;
    line-height: 16px;
    z-index: 20;
  }

  .maplibregl-popup-tip,
  .maplibregl-popup-content {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border-radius: 0.5em !important;
    font-size: 12px !important;
  }
</style>
{% endblock %}

{% block extra_js %}
<script src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"></script>
{% endblock %}

{% block content %}
<button id="directionToggle">Show Outbound</button>
<div id="map"></div>

<script>
  const savedView = JSON.parse(localStorage.getItem('mbt_map_view') || 'null');
  const routeId = {{ route.id }};
  const operatorName = "{{ operator.operator_name }}";

  let currentDirection = "inbound";
  let btMarkers = [];

  // Choose tile style
  {% if themeDark == 'True' %}
    tilesJSON = 'https://tiles.snubs.dev/styles/dark/style.json';
  {% else %}
    tilesJSON = 'https://tiles.snubs.dev/styles/light/style.json';
  {% endif %}

  const map = new maplibregl.Map({
    container: 'map',
    style: tilesJSON,
    center: savedView?.center || [-2.5, 54.5],
    zoom: savedView?.zoom || 5,
    dragRotate: false
  });

  map.on('style.load', () => {
    map.setProjection({
      type: 'globe'
    });
  });

  btMarkers.forEach(m => m.remove());
  btMarkers = [];

  function createLiveryIcon({ label = '', rotation = 0, bg = '#0000', css = null, textColour = '#fff', textStroke = "#0000", strokeWidth = "0px" } = {}) {
      const normalisedRotation = ((rotation % 360) + 360) % 360;
      const cellRotation = (normalisedRotation < 90 || normalisedRotation > 270) ? 0 : 180;
      const backgroundStyle = css ? `background: ${css};` : `background: ${bg};`;
      const html = document.createElement('div');
      html.innerHTML = `
        <div style="display:inline-block; transform: rotate(${rotation}deg);">
          <svg width="24" height="16" data-vehicle-id="51623" class="vehicle-marker" style="stroke: ${textStroke}; text-align: center; ${backgroundStyle} transform: rotate(${cellRotation}deg); border: 1px solid rgba(0,0,0); color: ${textColour}; fill: ${textColour}; stroke-width: ${strokeWidth};">
            <text x="12" y="12">${label}</text>
          </svg>
          <span style="display:flex; margin-top: -27px; margin-left: 16px; color:black;">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
              <path d="M8 6.65v10.69c0 .64.76.99 1.24.56l6.11-5.35c.34-.3.34-.83 0-1.13L9.24 6.07C8.76 5.65 8 5.99 8 6.63Z" />
            </svg>
          </span>
        </div>
      `;

      return html;
    }

  async function loadOperatorBT() {
    const b = map.getBounds();

    const q = new URLSearchParams({
      ymax: b.getNorth(),
      ymin: b.getSouth(),
      xmax: b.getEast(),
      xmin: b.getWest(),
      route_id: routeId,
    });

    const url = `/api/trips/simulated_positions/?${q}&limit=5000`;

    const res = await fetch(url);
    const data = await res.json();
    const vehicles = Array.isArray(data.results) ? data.results : [];

    btMarkers.forEach(m => m.remove());
    btMarkers = [];

    for (const v of vehicles) {
      const lat = v.lat;
      const lng = v.lng;
      if (!lat || !lng) continue;

      let heading = (v.heading ?? 0) + 180;
      const line = v.service?.line_name || "";
      const dest = v.destination || "";
      const serviceLink = v.service?.url || "";
      const vehicleLink = v.vehicle?.url || "";

      console.log("----");
      console.log(v.vehicle);
      console.log("----");

      // livery logic (copied from your working page)
      let css = v.vehicle?.right_css || null;

      if (heading > 180 && heading < 360) {
        css = v.vehicle?.right_css || null;
      } else {
        css = v.vehicle?.left_css || null;
      }

      const textColour = v.vehicle?.text_colour || (v.vehicle?.white_text ? "#fff" : "#000");
      const textStroke = v.vehicle?.stroke_colour ?? false;
      const strokeWidth = textStroke ? "2px" : "0px";
      heading = heading + 90;

      const el = createLiveryIcon({
        label: line,
        css,
        textColour,
        rotation: heading,
        textStroke,
        strokeWidth
      });

      const veh = v.vehicle || {};

      const m = new maplibregl.Marker({ element: el })
        .setLngLat([lng, lat])
        .setPopup(new maplibregl.Popup({ offset: 6 }).setHTML(`
          <a href="${serviceLink}">${line} to ${dest}</a><br>
          ${vehicleLink ? `<a href="${vehicleLink}">${veh.name || ''}</a>` : ""}<br>
          <span class="time-ago" data-time="${v.updated_at}">${timeAgo(v.updated_at)}</span>
          <small style="margin-bottom: 0;">Simulated Location</small>
        `))
        .addTo(map);

      btMarkers.push(m);
    }
  }


  map.addControl(new maplibregl.NavigationControl(), 'top-left');

  let markers = [];
  let routeLine = null;

  async function loadRoute(direction) {
    // Clear markers
    for (const m of markers) m.remove();
    markers = [];

    // Clear previous route line
    if (map.getLayer('routeLine')) map.removeLayer('routeLine');
    if (map.getSource('routeLine')) map.removeSource('routeLine');

    // Fetch route data
    const res = await fetch(`/api/routes/${routeId}/stops/?direction=${direction}`);
    if (!res.ok) {
      alert('Failed to load route stops');
      return;
    }

    const data = await res.json();

    const hasSnapped = data.has_snapped_route === true;

    const stops = data.stops || [];
    const snapped = data.snapped_route || [];

    if (stop.cords === null) {
      return;
    }

    // Parse stop coords
    const stopCoords = stops
      .map(stop => stop.cords?.split(',').map(Number))
      .filter(c => c && c.length === 2 && !isNaN(c[0]) && !isNaN(c[1]))
      .map(([lat, lon]) => [lon, lat]); // convert to [lon,lat]

    // Decide which geometry to use
    let geometryToDraw = [];

    if (hasSnapped && snapped.length > 1) {
        // snapped is already [lon,lat]
        geometryToDraw = snapped;
    } else {
        // fallback: straight lines between stops
        geometryToDraw = stopCoords;
    }

    // Draw the polyline
    if (geometryToDraw.length >= 2) {
      map.addSource('routeLine', {
        type: 'geojson',
        data: {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: geometryToDraw }
        }
      });

      map.addLayer({
        id: 'routeLine',
        type: 'line',
        source: 'routeLine',
        paint: {
          'line-color': '#2f80ed',
          'line-width': 3
        }
      });

      // Fit bounds
      const bounds = new maplibregl.LngLatBounds();
      geometryToDraw.forEach(c => bounds.extend(c));
      map.fitBounds(bounds, { padding: 60 });
    }

    // Add stop markers
    for (const stop of stops) {
      const [lat, lon] = stop.cords.split(',').map(Number);
      if (isNaN(lat) || isNaN(lon)) continue;

      const el = document.createElement('div');
      el.style.cssText = `
        width:10px;height:10px;
        border:3px solid #2f80ea;
        border-radius:50%;
        background:#fff;
        cursor:pointer;
      `;

      const marker = new maplibregl.Marker({ element: el })
        .setLngLat([lon, lat])
        .setPopup(new maplibregl.Popup({ offset: 6 }).setHTML(
          `<a href="/stop/?name=${encodeURIComponent(stop.stop)}">${stop.stop}</a>`
        ))
        .addTo(map);

      markers.push(marker);
    }
  }

  // Toggle inbound/outbound
  const toggleBtn = document.getElementById('directionToggle');
  toggleBtn.addEventListener('click', () => {
    if (currentDirection === 'inbound') {
      currentDirection = 'outbound';
      toggleBtn.textContent = 'Show Inbound';
    } else {
      currentDirection = 'inbound';
      toggleBtn.textContent = 'Show Outbound';
    }
    loadRoute(currentDirection);
  });

  map.on('load', async () => {
    await loadOperatorBT(); 
    await loadRoute(currentDirection);
  });

  map.on("moveend", loadOperatorBT);
setInterval(loadOperatorBT, 30000);

function timeAgo(dateString) {
    if (!dateString) return '';
    const seconds = Math.floor((new Date() - new Date(dateString)) / 1000);
    if (seconds < 60) return `${seconds} sec${seconds !== 1 ? 's' : ''} ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes} min${minutes !== 1 ? 's' : ''} ago`;
    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours} hr${hours !== 1 ? 's' : ''} ago`;
    const days = Math.floor(hours / 24);
    return `${days} day${days !== 1 ? 's' : ''} ago`;
  }

setInterval(() => {
    document.querySelectorAll('.time-ago').forEach(el => {
      const dateString = el.dataset.time;
      if (dateString) {
        el.textContent = timeAgo(dateString);
      }
    });
  }, 1000); 
</script>
{% endblock %}
